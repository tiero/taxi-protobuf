syntax = "proto3";
option go_package = "github.com/vulpemventures/taxi-protobuf/generated/go/trade";

service Taxi {
  // ListAssets rpc returns a subset of supported elements assets that could be accepted as payment
  // for topups
  rpc ListAssets(ListAssetsRequest) returns (ListAssetsReply);
  // TopupWithAsset rpc returns the a partial signed elements transaction with a LBTC input (eventual change) and a asset denominated output as payout fot the taxi.
  // The transaction is signed with SIGHASH_SINGLE | ANYONECANPAY 
  rpc TopupWithAsset(TopupWithAssetRequest) returns (TopupWithAssetReply);
}

message ListAssetsRequest {}
message ListAssetsReply {
  repeated string asset_hash = 1; // asset hash accepted as payout
}
message TopupWithAssetRequest {
  string asset_hash = 1; // asset hash to be used for payout
  uint64 fee_amount = 2; // amount in satoshis of bitcoin needed to cover the fees. It's up to the client to estimate and ask the precise amount
  uint64 millisat_per_byte = 3; // how many millisatoshi per byte we want to spend. ie. 0.1 sat/byte is 100
}
message TopupWithAssetReply {
  Topup topup = 1;
  uint64 expiry = 2; // the unix timestamp after wich the locked LBTC input will provably be double-spent
  string blinding_key = 3; // the hex encoded blinding private key of the locked LBTC input
}

message Topup {
  string topup_id = 1; //random identifier of the currer topup
  string partial = 2; // PSET signed with SIGHASH_SINGLE | ANYONECANPAY
  string asset_hash = 3; // the asset hash used as payout for bitcoin fees
  uint64 asset_amount = 4; // the asset denominated amount expressed in satoshis to be used as payout. It includes also the spread as taxi service fee
  float asset_price = 5; // the price of bitcoin expressed in asset
  int32 basis_point = 6; // the spread expressed in basis point on top the amount needed to repay for bitcoin fees
}
